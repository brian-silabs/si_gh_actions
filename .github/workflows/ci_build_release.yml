name: CI Build Artifacts and Create Release Draft 

on:
  push:
    branches:
      - dev
  pull_request:
    branches:
      - dev

jobs:
  generate_build_and_release:
    runs-on: ubuntu-latest
    steps:
      # Prepare all global env vars
      - name: Preparing Build env vars
        run: |
          echo "SOLUTION_REL_DIR=solution" >> $GITHUB_ENV
          echo "DEPENDENCIES_REL_DIR=dependencies" >> $GITHUB_ENV
          echo "TOOLS_REL_DIR=tools" >> $GITHUB_ENV
          echo "ARM_GCC_ABS_DIR=/opt/gcc-arm-none-eabi" >> $GITHUB_ENV
          echo "ARM_GCC_BIN_ABS_DIR=/opt/gcc-arm-none-eabi/bin" >> $GITHUB_ENV

      - name: Preparing env vars
        run: |
          echo "TOOLS_ABS_DIR=$GITHUB_WORKSPACE/$TOOLS_REL_DIR" >> $GITHUB_ENV
          echo "DEPENDENCIES_ABS_DIR=$GITHUB_WORKSPACE/$DEPENDENCIES_REL_DIR" >> $GITHUB_ENV
          echo "SOLUTION_ABS_DIR=$GITHUB_WORKSPACE/$SOLUTION_REL_DIR" >> $GITHUB_ENV
          echo "REPO_NAME=${GITHUB_REPOSITORY#$GITHUB_REPOSITORY_OWNER/}" >> $GITHUB_ENV
          echo "RUNNER_ARCHITECTURE=$(arch)" >> $GITHUB_ENV

      - name: Preparing env vars for tools
        run: |
          echo "ZAP_REL_DIR=${{ env.TOOLS_REL_DIR }}/zap" >> $GITHUB_ENV
          echo "ZAP_ABS_DIR=${{ env.TOOLS_ABS_DIR }}/zap" >> $GITHUB_ENV
          echo "SLC_CLI_REL_DIR=${{ env.TOOLS_REL_DIR }}/slc_cli" >> $GITHUB_ENV
          echo "SLC_CLI_ABS_DIR=${{ env.TOOLS_ABS_DIR }}/slc_cli" >> $GITHUB_ENV
          echo "COMMANDER_REL_DIR=${{ env.TOOLS_REL_DIR }}/commander" >> $GITHUB_ENV
          echo "COMMANDER_ABS_DIR=${{ env.TOOLS_ABS_DIR }}/commander" >> $GITHUB_ENV
          echo "POST_BUILD_EXE=${{ env.TOOLS_ABS_DIR }}/commander/commander" >> $GITHUB_ENV
          echo "POST_BUILD_ARTIFACTS_REL_DIR=${{ env.SOLUTION_REL_DIR }}/artifacts" >> $GITHUB_ENV
          echo "POST_BUILD_ARTIFACTS_ABS_DIR=${{ env.SOLUTION_ABS_DIR }}/artifacts" >> $GITHUB_ENV

      - name: Export all tools to PATH
        run: |
          echo "${{ env.ARM_GCC_BIN_ABS_DIR }}" >> $GITHUB_PATH
          echo "${{ env.SLC_CLI_ABS_DIR }}" >> $GITHUB_PATH
          echo "${{ env.ZAP_ABS_DIR }}" >> $GITHUB_PATH
          echo "${{ env.COMMANDER_ABS_DIR }}" >> $GITHUB_PATH
          echo "STUDIO_ADAPTER_PACK_PATH=${{ env.ZAP_ABS_DIR }}" >> $GITHUB_ENV
          echo "POST_BUILD_EXE=${{ env.COMMANDER_ABS_DIR }}/commander" >> $GITHUB_ENV

      # Prepare folder structure
      - name: Create build environment 
        run: |
          mkdir -p ${{ env.TOOLS_ABS_DIR }}
          mkdir -p ${{ env.DEPENDENCIES_ABS_DIR }}
          mkdir -p ${{ env.SOLUTION_ABS_DIR }}
          mkdir -p ${{ env.ARM_GCC_ABS_DIR }}

      # Prepare runtime environment
      - name: Prepare build envirnoment 
        run: |
          sudo apt update
          sudo apt -qq install -y git curl zip unzip wget gpg python3 python3-pip python3-yaml yq cmake make ninja-build ca-certificates openssl libgl1 libglib2.0-0
          sudo apt update
          wget -qO- https://apt.corretto.aws/corretto.key | sudo gpg --dearmor -o /usr/share/keyrings/corretto-keyring.gpg && echo "deb [signed-by=/usr/share/keyrings/corretto-keyring.gpg] https://apt.corretto.aws stable main" | sudo tee /etc/apt/sources.list.d/corretto.list
          sudo apt update
          sudo apt -qq install -y java-21-amazon-corretto-jdk
          java --version
          sudo update-alternatives --set java /usr/lib/jvm/java-21-amazon-corretto/bin/java
          java --version

      # Download repo code
      - name: Checkout repo code 
        uses: actions/checkout@v4
        with:
          path: ${{ env.SOLUTION_REL_DIR }} # Requires relative path

      # Add Repo and SLCP path to ENV variables 
      - name: Update env vars with SLCP Location data
        run: |
          echo "SLCP_ABS_PATH=$(find ${{ env.SOLUTION_ABS_DIR }} -type f -name "*.slcp")" >> $GITHUB_ENV
          echo "SLCP_REL_PATH=$(find ${{ env.SOLUTION_REL_DIR }} -type f -name "*.slcp")" >> $GITHUB_ENV
          echo "SLCP_FILENAME=$(find ${{ env.SOLUTION_ABS_DIR }} -name "*.slcp" -type f -printf "%f\n")" >> $GITHUB_ENV
          echo "SLPB_ABS_PATH=$(find ${{ env.SOLUTION_ABS_DIR }} -type f -name "*.slpb")" >> $GITHUB_ENV
          echo "SLPB_REL_PATH=$(find ${{ env.SOLUTION_REL_DIR }} -type f -name "*.slpb")" >> $GITHUB_ENV
          echo "SLPB_FILENAME=$(find ${{ env.SOLUTION_ABS_DIR }} -name "*.slpb" -type f -printf "%f\n")" >> $GITHUB_ENV
          echo "RELEASE_VERSION=$(cat ${{ env.SOLUTION_ABS_DIR }}/VERSION.md)" >> $GITHUB_ENV
          cd ${{ env.SOLUTION_ABS_DIR }}
          echo "RELEASE_SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
          echo "RELEASE_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

      # Read the SLCP contents
      - name: Read SLCP contents
        id: read_slcp
        uses: teunmooij/yaml@v1
        with:
          from-file: ${{ env.SLCP_REL_PATH }} # Requires relative path

      # Read the SLPB contents
      - name: Read SLPB contents
        id: read_slpb
        uses: teunmooij/yaml@v1
        with:
          from-file: ${{ env.SLPB_REL_PATH }} # Requires relative path

      # Read the Toolchain dependencies contents
      - name: Read Toolchain dependencies contents
        id: read_toolchain
        uses: teunmooij/yaml@v1
        with:
          from-file: ${{ env.SOLUTION_REL_DIR }}/.github/sdk_toolchain_dependencies.yml

      # Add Project Name and required SDK version to ENV variables
      - name: Update env vars with Project SLCP extracted data
        run: |
          echo "SDK_ID=${{ (fromJson(steps.read_slcp.outputs.data).sdk).id }}" >> $GITHUB_ENV
          echo "SDK_REL_DIR=${{ env.DEPENDENCIES_REL_DIR }}/${{ (fromJson(steps.read_slcp.outputs.data).sdk).id }}" >> $GITHUB_ENV
          echo "SDK_ABS_DIR=${{ env.DEPENDENCIES_ABS_DIR }}/${{ (fromJson(steps.read_slcp.outputs.data).sdk).id }}" >> $GITHUB_ENV
          echo "SDK_VERSION=${{ (fromJson(steps.read_slcp.outputs.data).sdk).version }}" >> $GITHUB_ENV
          echo "PROJECT_NAME=${{ fromJson(steps.read_slcp.outputs.data).project_name }}" >> $GITHUB_ENV
          echo "CMAKE_WORKING_ABS_DIR=${{ env.SOLUTION_ABS_DIR }}/${{ fromJson(steps.read_slcp.outputs.data).project_name }}_cmake" >> $GITHUB_ENV
          echo "ARM_GCC_VERSION=${{ fromJson(steps.read_toolchain.outputs.data)[format('{0}', (fromJson(steps.read_slcp.outputs.data).sdk).id )][format('v{0}', (fromJson(steps.read_slcp.outputs.data).sdk).version )].gcc }}" >> $GITHUB_ENV

      - name: Detect ZAP config
        id: zap
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(config/zcl/*.zap)
          if [ ${#files[@]} -gt 0 ]; then
            # pick the first .zap; tweak if you prefer newest: files=( $(ls -t config/zcl/*.zap) )
            ZAP_FILE="${files[0]}"
            echo "found=true"        >> "$GITHUB_OUTPUT"
            echo "zap_file=$ZAP_FILE" >> "$GITHUB_OUTPUT"
            # a stable cache key: hash the zap file content
            echo "zap_hash=$(sha256sum "$ZAP_FILE" | cut -d' ' -f1)" >> "$GITHUB_OUTPUT"
            echo "Found ZAP: $ZAP_FILE"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "No ZAP file under config/zcl/. Will skip ZAP download/build."
          fi

      # Download Simplicity SDK
      - name: Checkout SiSDK 
        uses: actions/checkout@v4
        with:
          lfs: false # Requires below workaround
          repository: SiliconLabs/${{ env.SDK_ID }}
          ref: v${{ env.SDK_VERSION }} # Silicon Labs changes the versioning scheme very often
          path: ${{ env.SDK_REL_DIR }}
          token: ${{ secrets.ACCESS_TOKEN }}

      # Workaround for lfs files, static libraries
      - name: LFS checkout
        run: |
          cd ${{ env.SDK_ABS_DIR }}
          git lfs pull

      # Download Commander to generate projects
      - name: Download and Unzip Simplicity Commander
        run: |
          curl -LO https://www.silabs.com/documents/public/software/SimplicityCommander-Linux.zip
          unzip -qq SimplicityCommander-Linux.zip 
          tar -xf ./SimplicityCommander-Linux/Commander_linux_x86_64_*.tar.bz -C ${{ env.TOOLS_ABS_DIR }}

      # Download SLC CLI to generate projects
      - name: Download and Unzip SLC CLI
        run: |
          curl -LO https://www.silabs.com/documents/login/software/slc_cli_linux.zip
          unzip -qq slc_cli_linux.zip -d ${{ env.TOOLS_ABS_DIR }}

      # Download ARM GCC Toolchain - Version should be retrieved somewhere, where compatibilitiy with SDKs is checked
      - name: Download and Unzip ARM GCC Toolchain 
        run: |
          curl -Lo gcc-arm-none-eabi.tar.xz "https://developer.arm.com/-/media/Files/downloads/gnu/${{ env.ARM_GCC_VERSION }}/binrel/arm-gnu-toolchain-${{ env.ARM_GCC_VERSION }}-${{ env.RUNNER_ARCHITECTURE }}-arm-none-eabi.tar.xz"
          tar xf gcc-arm-none-eabi.tar.xz --strip-components=1 -C ${{ env.ARM_GCC_ABS_DIR }}


      - name: Get Latest Zap Version
        uses: oprypin/find-latest-tag@v1
        with:
          repository: project-chip/zap  # The repository to scan.
          releases-only: true 
          regex: '^v\d{4}\.\d{2}\.\d{2}$'
        id: zap_latest  # The step ID to refer to later.

      # Download ZAP Tool for Zigbee projects
      - name: Checkout ZAP Tool
        if: steps.zap.outputs.found == 'true'
        uses: actions/checkout@v4
        with:
          repository: project-chip/zap
          ref: ${{ steps.zap_latest.outputs.tag }}
          path: ${{ env.ZAP_REL_DIR }}
          token: ${{ secrets.ACCESS_TOKEN }}

      # Build ZAP
      - name: Setup Node # Not sure if this is required
        if: steps.zap.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: ${{ env.ZAP_REL_DIR }}/package-lock.json

      # Install ZAP - TODO check certificate issue
      - name: Build and install ZAP (Unsecure NODE_TLS_REJECT_UNAUTHORIZED = 0)
        if: steps.zap.outputs.found == 'true'
        working-directory: ${{ env.ZAP_REL_DIR }}
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: 0
        run: |
          npm install

      - name: SLC Configure SDK Trust and Toolchain
        run: |
          slc configuration -gcc ${{ env.ARM_GCC_ABS_DIR }} --sdk ${{ env.SDK_ABS_DIR }}
          slc signature trust --sdk ${{ env.SDK_ABS_DIR }}

      # Gather Targets and configs from target_info.yaml file
      - name: Gather Targets and configs from target_info.yaml file
        id: read_build_configs
        uses: teunmooij/yaml@v1
        with:
          from-file: ${{ env.SOLUTION_REL_DIR }}/target_info.yaml

      # Export targets information (supports empty target_info.yaml)
      - name: Update env vars with Project SLCP extracted data
        id: export_targets
        shell: bash
        run: |
          set -euo pipefail

          # Read the JSON produced earlier by your 'read_build_configs' step.
          # Expecting shape: { "targets": [ { "target_opn": "...", "configs": "...", "name": "..." }, ... ] }
          RAW='${{ steps.read_build_configs.outputs.data }}'

          # If the config step produced nothing or empty, fall back to empty list
          if [ -z "$RAW" ] || [ "$RAW" = "null" ]; then
            echo "No targets JSON. Proceeding with default-only build."
            echo "TARGET_COUNT=0" >> "$GITHUB_ENV"
            exit 0
          fi

          python3 - << 'PY'
          import json, os, re
          raw = json.loads(r'''${{ steps.read_build_configs.outputs.data }}''')
          targets = (raw.get("targets") or []) if isinstance(raw, dict) else []
          # sanitize names for folder usage
          def slug(s):
              s = (s or "t").strip()
              s = re.sub(r'[^A-Za-z0-9._-]+','_', s)
              return s or "t"
          print(f"Found {len(targets)} targets")
          with open(os.environ["GITHUB_ENV"], "a") as f:
              f.write(f"TARGET_COUNT={len(targets)}\n")
              for i,t in enumerate(targets):
                  name = slug(t.get("name") or t.get("target_opn") or f"t{i}")
                  opn  = (t.get("target_opn") or "").strip()
                  cfg  = (t.get("configs") or "").strip()
                  f.write(f"TARGET_{i}_NAME={name}\n")
                  f.write(f"TARGET_{i}_OPN={opn}\n")
                  f.write(f"TARGET_{i}_CONFIGS={cfg}\n")
          PY

      # Parse steps[].output → parent dirs (Bash + yq)
      - name: Parse SLPB to get output parent dirs
        id: slpb
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "❌ Failed at ${BASH_SOURCE[0]}:${LINENO}"' ERR

          slpb="${SLPB_ABS_PATH:-}"
          if [[ -z "$slpb" || ! -r "$slpb" ]]; then
            [[ -n "${GITHUB_OUTPUT:-}" ]] && {
              echo "slpb_dirs_count=0" >> "$GITHUB_OUTPUT"
              echo "slpb_dirs_json=[]" >> "$GITHUB_OUTPUT"
            }
            [[ -n "${GITHUB_ENV:-}" ]] && echo "SLPB_DIRS=" >> "$GITHUB_ENV"
            echo "::notice title=SLPB::No readable SLPB at: ${slpb:-<unset>}"
            exit 0
          fi

          # Ensure yq is available (lightweight)
          if ! command -v yq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y yq
          fi

          # Get steps[].output values, then uniqued parent dirs
          mapfile -t outputs < <(yq -r '.steps[]? | select(has("output")) | .output' "$slpb" | sed 's/\r$//')

          declare -A seen=()
          dirs=()
          for out in "${outputs[@]}"; do
            [[ -n "${out// }" ]] || continue
            parent="$(dirname -- "$out")"
            [[ -n "$parent" ]] || continue
            if [[ -z "${seen[$parent]:-}" ]]; then
              seen["$parent"]=1
              dirs+=("$parent")
            fi
          done

          # Build a tiny JSON array (no Python)
          json='['
          for i in "${!dirs[@]}"; do
            d="${dirs[$i]}"
            d=${d//\\/\\\\}; d=${d//\"/\\\"}
            [[ $i -gt 0 ]] && json+=','
            json+="\"$d\""
          done
          json+=']'
          count="${#dirs[@]}"

          # Step outputs (for later steps): count + JSON
          if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
            {
              echo "slpb_dirs_count=$count"
              echo "slpb_dirs_json=$json"
            } >> "$GITHUB_OUTPUT"
          fi

          # Newline-separated env var for easy looping
          if [[ -n "${GITHUB_ENV:-}" ]]; then
            if (( count > 0 )); then
              {
                echo "SLPB_DIRS<<EOF"
                printf '%s\n' "${dirs[@]}"
                echo "EOF"
              } >> "$GITHUB_ENV"
            else
              echo "SLPB_DIRS=" >> "$GITHUB_ENV"
            fi
          fi

          echo "::notice title=SLPB::Found ${count} artifact parent director$([[ $count == 1 ]] && echo 'y' || echo 'ies')"

      - name: Use SLPB dirs
        shell: bash
        run: |
          echo "Count: ${{ steps.slpb.outputs.slpb_dirs_count }}"
          echo "JSON : ${{ steps.slpb.outputs.slpb_dirs_json }}"
          echo "List :"
          while IFS= read -r d; do
            [[ -n "$d" ]] && echo " - $d"
          done <<< "${SLPB_DIRS:-}"

      # Generate projects:
      # - default (NO --with / --configuration) → ${PROJECT_NAME}_default
      # - each target in target_info.yaml      → ${PROJECT_NAME}_${TARGET_<i>_NAME}
      - name: SLC Generate & Build Project(s)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "❌ Failed at ${BASH_SOURCE[0]}:${LINENO}"' ERR

          : "${PROJECT_NAME:?PROJECT_NAME must be set}"
          : "${SOLUTION_ABS_DIR:?}"; : "${SLCP_FILENAME:?}"
          : "${POST_BUILD_ARTIFACTS_ABS_DIR:?}"

          # Common vars and directories
          SOL_ABS_DIR_CMAKE="${SOLUTION_ABS_DIR}/${PROJECT_NAME}_cmake"
          mkdir -p "${POST_BUILD_ARTIFACTS_ABS_DIR}"

          # --- helper: copy SLPB dirs from a base into a dest root, preserving relative structure
          copy_slpb_dirs() {
            local src_base="$1" dest_root="$2" tag="$3"
            [[ -z "${SLPB_DIRS:-}" ]] && return 0
            while IFS= read -r rel; do
              [[ -z "$rel" ]] && continue
              local src="${src_base}/${rel}"
              local dst="${dest_root}/${rel}"
              if [[ -d "$src" || -f "$src" ]]; then
                mkdir -p "$(dirname "$dst")"
                if [[ -d "$src" ]]; then
                  cp -a "$src/." "$dst"
                else
                  cp -a "$src" "$dst"
                fi
                echo "[$tag] Copied SLPB: $src -> $dst"
              else
                echo "[$tag] Note: SLPB path not found (skipped): $src"
              fi
            done <<< "${SLPB_DIRS}"
          }

          # 1) Default project (no --with / --configuration)
          DEFAULT_PROJECT_ARTIFACTS_ABS_DIR="${SOLUTION_ABS_DIR}/${PROJECT_NAME}_default_artifacts"
          DEFAULT_PROJECT_ARTIFACTS_ABS_FILE_DEST="${POST_BUILD_ARTIFACTS_ABS_DIR}/${PROJECT_NAME}_default_artifacts.zip"
          echo "Generating DEFAULT build config Artifacts into: ${DEFAULT_PROJECT_ARTIFACTS_ABS_DIR}"
          mkdir -p "${DEFAULT_PROJECT_ARTIFACTS_ABS_DIR}"
          pushd "${SOLUTION_ABS_DIR}" >/dev/null
            # Delete existing cmake directory if any
            rm -rf "${SOL_ABS_DIR_CMAKE}"
            # Generate new cmake files
            slc generate "${SLCP_FILENAME}" -cpsdk -tlcn gcc -o cmake
            echo "=== Building ${PROJECT_NAME}_default ==="
            pushd "${SOL_ABS_DIR_CMAKE}" >/dev/null
              # Build the project
              cmake --workflow --preset project --fresh
              # Create size report
              arm-none-eabi-size "${SOL_ABS_DIR_CMAKE}/build/default_config/${PROJECT_NAME}.out" -A >> "${SOL_ABS_DIR_CMAKE}/build/default_config/${PROJECT_NAME}_SizeReport.log"
              # Copy EVERYTHING from the default_config build tree
              cp -a "${SOL_ABS_DIR_CMAKE}/build/default_config/." "${DEFAULT_PROJECT_ARTIFACTS_ABS_DIR}"

              # Also copy SLPB dirs into POST_BUILD artifacts for upload
              copy_slpb_dirs "${SOLUTION_ABS_DIR}" "${DEFAULT_PROJECT_ARTIFACTS_ABS_DIR}/slpb/default" "default->post-build"

              # Zip artifacts for release upload
              pushd "${DEFAULT_PROJECT_ARTIFACTS_ABS_DIR}" >/dev/null
                zip -q -r "${DEFAULT_PROJECT_ARTIFACTS_ABS_FILE_DEST}" .
              popd >/dev/null
            popd >/dev/null
          popd >/dev/null

          # 2) Extra targets from target_info.yaml (if any)
          CNT="${TARGET_COUNT:-0}"
          if [[ "$CNT" -gt 0 ]]; then
            for ((i=0;i<CNT;i++)); do
              name_var="TARGET_${i}_NAME"
              opn_var="TARGET_${i}_OPN"
              cfg_var="TARGET_${i}_CONFIGS"

              NAME="${!name_var-}"   # may be empty
              OPN="${!opn_var-}"     # may be empty
              CFG="${!cfg_var-}"     # may be empty

              PROJECT_CONFIG_ABS_OUT_DIR="${SOLUTION_ABS_DIR}/${PROJECT_NAME}_${NAME}"
              echo "Generating TARGET ${i}: name=${NAME:-<none>} opn=${OPN:-<none>} cfg=${CFG:-<none>} → ${PROJECT_CONFIG_ABS_OUT_DIR}"
              mkdir -p "${PROJECT_CONFIG_ABS_OUT_DIR}"

              # Build slc args conditionally so we don't pass empty flags
              SLC_ARGS=( generate "${SLCP_FILENAME}" -cpsdk -tlcn gcc -o cmake -d "${PROJECT_CONFIG_ABS_OUT_DIR}" )
              [[ -n "${OPN}" ]] && SLC_ARGS+=( --with "${OPN}" )
              [[ -n "${CFG}" ]] && SLC_ARGS+=( --configuration "${CFG}" )

              pushd "${SOLUTION_ABS_DIR}" >/dev/null
                slc "${SLC_ARGS[@]}"
                echo "=== Building ${PROJECT_NAME}_${NAME} ==="
                pushd "${PROJECT_CONFIG_ABS_OUT_DIR}" >/dev/null
                  cmake --workflow --preset project --fresh
                popd >/dev/null
              popd >/dev/null

              # Copy SLPB-declared dirs into POST_BUILD artifacts under a namespaced folder
              copy_slpb_dirs "${SOLUTION_ABS_DIR}" "${POST_BUILD_ARTIFACTS_ABS_DIR}/slpb/${PROJECT_NAME}_${NAME}" "target:${NAME}->post-build"
            done
          else
            echo "No extra targets. Only default will be built."
          fi


      - name: Create Release Draft
        uses: release-drafter/release-drafter@v6
        id : create_release
        env:
          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        with:
          tag: v${{ env.RELEASE_VERSION }}
          commitish: ${{ env.RELEASE_SHA }} # An optional commit reference. This will be used to create the tag if it does not exist.
          name: ${{ env.PROJECT_NAME }} v${{ env.RELEASE_VERSION }}
      
      - name: Upload Assets
        uses: shogo82148/actions-upload-release-asset@v1.8.2
        with:
          github_token: ${{ secrets.ACCESS_TOKEN }}
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          overwrite: true
          asset_path: | 
            ${{ env.POST_BUILD_ARTIFACTS_ABS_DIR }}/*.zip

      # # Add slpb artifacts to Release - If applicable, I do not like using artifact and would have preferred using the paths from slpb instead
      # - name: Upload postbuild artifacts if present
      #   if: ${{ hashFiles(env.POST_BUILD_ARTIFACTS_ABS_OUT_FILE) != '' }}
      #   uses: shogo82148/actions-upload-release-asset@v1.8.2
      #   with:
      #     github_token: ${{ secrets.ACCESS_TOKEN }}
      #     upload_url: ${{ steps.create_release.outputs.upload_url }}
      #     overwrite: true
      #     asset_path: | 
      #       ${{ env.POST_BUILD_ARTIFACTS_ABS_OUT_FILE }}

  # update_changelog:
  #   name: Update Changelog
  #   needs: prepare_build_environment
  #   runs-on: ubuntu-latest
  #   steps:

      - name: Update Changelog
        uses: stefanzweifel/changelog-updater-action@v1
        with:
          latest-version: v${{ env.RELEASE_VERSION }}
          release-notes: ${{ steps.create_release.outputs.body }}
          path-to-changelog: ${{ env.SOLUTION_REL_DIR }}/CHANGELOG.md

      # Requires permissions at the repository level : Settings -> Action -> General -> Workflow permissions and choose read and write permissions
      - name: Commit updated Changelog
        uses: stefanzweifel/git-auto-commit-action@v5
        env:
          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        with:
          commit_message: 'docs(changelog): update changelog'
          file_pattern: CHANGELOG.md
          repository: ${{ env.SOLUTION_REL_DIR }}
